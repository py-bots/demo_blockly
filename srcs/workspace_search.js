/*! For license information please see index.js.LICENSE.txt */
!function (t, e) { if ("object" == typeof exports && "object" == typeof module) module.exports = e(require("blockly/core")); else if ("function" == typeof define && define.amd) define(["blockly/core"], e); else { var s = "object" == typeof exports ? e(require("blockly/core")) : e(t.Blockly); for (var i in s) ("object" == typeof exports ? exports : t)[i] = s[i] } }(this, (function (t) { return (() => { "use strict"; var e = { 573: e => { e.exports = t } }, s = {}; function i(t) { var o = s[t]; if (void 0 !== o) return o.exports; var n = s[t] = { exports: {} }; return e[t](n, n.exports, i), n.exports } i.d = (t, e) => { for (var s in e) i.o(e, s) && !i.o(t, s) && Object.defineProperty(t, s, { enumerable: !0, get: e[s] }) }, i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), i.r = t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }; var o = {}; return (() => { i.r(o), i.d(o, { WorkspaceSearch: () => n }); const t = ["path.blocklyPath.blockly-ws-search-highlight {", "fill: black;", "}", "path.blocklyPath.blockly-ws-search-highlight.blockly-ws-search-current {", "fill: grey;", "}", ".blockly-ws-search-close-btn {", "background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE0Ij48cGF0aCBkPSJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyeiIvPjxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=) no-repeat top left;", "}", ".blockly-ws-search-next-btn {", "background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE0Ij48cGF0aCBkPSJNNy40MSA4LjU5TDEyIDEzLjE3bDQuNTktNC41OEwxOCAxMGwtNiA2LTYtNiAxLjQxLTEuNDF6Ii8+PHBhdGggZD0iTTAgMGgyNHYyNEgwVjB6IiBmaWxsPSJub25lIi8+PC9zdmc+) no-repeat top left;", "}", ".blockly-ws-search-previous-btn {", "background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE0Ij48cGF0aCBkPSJNNy40MSAxNS40MUwxMiAxMC44M2w0LjU5IDQuNThMMTggMTRsLTYtNi02IDZ6Ii8+PHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==) no-repeat top left;", "}", ".blockly-ws-search {", "background: white;", "border: solid lightgrey .5px;", "box-shadow: 0px 10px 20px grey;", "justify-content: center;", "padding: .25em;", "position: absolute;", "z-index: 70;", "}", ".blockly-ws-search-input input {", "border: none;", "}", ".blockly-ws-search button {", "border: none;", "}", ".blockly-ws-search-actions {", "display: flex;", "}", ".blockly-ws-search-container {", "display: flex;", "}", ".blockly-ws-search-content {", "display: flex;", "}"], e = function () { let e = !1; return function () { if (e) return; e = !0; const s = t.join("\n"), i = document.createElement("style"); i.id = "blockly-ws-search-style"; const o = document.createTextNode(s); i.appendChild(o), document.head.insertBefore(i, document.head.firstChild) } }(); var s = i(573); class n { constructor(t) { this.workspace_ = t, this.id = "workspaceSearch", this.htmlDiv_ = null, this.actionDiv_ = null, this.inputElement_ = null, this.textInputPlaceholder_ = "Search", this.blocks_ = [], this.currentBlockIndex_ = -1, this.searchText_ = "", this.searchOnInput = !0, this.caseSensitive = !1, this.preserveSelected = !0, this.boundEvents_ = [] } init() { this.workspace_.getComponentManager().addComponent({ component: this, weight: 0, capabilities: [s.ComponentManager.Capability.POSITIONABLE] }), e(), this.createDom_(), this.setVisible_(!1), this.workspace_.resize() } dispose() { for (const t of this.boundEvents_) s.unbindEvent_(t); this.boundEvents_ = null, this.htmlDiv_ && (this.htmlDiv_.remove(), this.htmlDiv_ = null), this.actionDiv_ = null, this.inputElement_ = null } createDom_() { const t = this.workspace_.getInjectionDiv(); this.addEvent_(t, "keydown", this, (t => this.onWorkspaceKeyDown_(t))), this.htmlDiv_ = document.createElement("div"), s.utils.dom.addClass(this.htmlDiv_, "blockly-ws-search"); const e = document.createElement("div"); s.utils.dom.addClass(e, "blockly-ws-search-container"); const i = document.createElement("div"); s.utils.dom.addClass(i, "blockly-ws-search-content"), e.appendChild(i); const o = document.createElement("div"); s.utils.dom.addClass(o, "blockly-ws-search-input"), this.inputElement_ = this.createTextInput_(), this.addEvent_(this.inputElement_, "keydown", this, (t => this.onKeyDown_(t))), this.addEvent_(this.inputElement_, "input", this, (() => this.onInput_())), this.addEvent_(this.inputElement_, "click", this, (() => this.searchAndHighlight(this.searchText_, this.preserveSelected))), o.appendChild(this.inputElement_), i.appendChild(o), this.actionDiv_ = document.createElement("div"), s.utils.dom.addClass(this.actionDiv_, "blockly-ws-search-actions"), i.appendChild(this.actionDiv_); const n = this.createNextBtn_(); n && this.addActionBtn(n, (() => this.next())); const l = this.createPreviousBtn_(); l && this.addActionBtn(l, (() => this.previous())); const c = this.createCloseBtn_(); c && (this.addBtnListener_(c, (() => this.close())), e.appendChild(c)), this.htmlDiv_.appendChild(e), t.insertBefore(this.htmlDiv_, this.workspace_.getParentSvg()) } addEvent_(t, e, i, o) { const n = s.browserEvents.conditionalBind(t, e, i, o); this.boundEvents_.push(n) } addActionBtn(t, e) { this.addBtnListener_(t, e), this.actionDiv_.appendChild(t) } createTextInput_() { const t = document.createElement("input"); return t.type = "text", t.setAttribute("placeholder", this.textInputPlaceholder_), t } createNextBtn_() { return this.createBtn_("blockly-ws-search-next-btn", "Find next") } createPreviousBtn_() { return this.createBtn_("blockly-ws-search-previous-btn", "Find previous") } createCloseBtn_() { return this.createBtn_("blockly-ws-search-close-btn", "Close search bar") } createBtn_(t, e) { const i = document.createElement("button"); return s.utils.dom.addClass(i, t), i.setAttribute("aria-label", e), i } addBtnListener_(t, e) { this.addEvent_(t, "click", this, e), this.addEvent_(t, "keydown", this, (t => { t.keyCode === s.utils.KeyCodes.ENTER ? (e(t), t.preventDefault()) : t.keyCode === s.utils.KeyCodes.ESC && this.close(), t.stopPropagation() })) } getBoundingRectangle() { return null } position(t, e) { this.workspace_.RTL ? this.htmlDiv_.style.left = t.absoluteMetrics.left + "px" : t.toolboxMetrics.position === s.TOOLBOX_AT_RIGHT ? this.htmlDiv_.style.right = t.toolboxMetrics.width + "px" : this.htmlDiv_.style.right = "0", this.htmlDiv_.style.top = t.absoluteMetrics.top + "px" } onInput_() { if (this.searchOnInput) { const t = this.inputElement_.value.trim(); t !== this.searchText_ && this.searchAndHighlight(t, this.preserveSelected) } } onKeyDown_(t) { if (t.keyCode === s.utils.KeyCodes.ESC) this.close(); else if (t.keyCode === s.utils.KeyCodes.ENTER) if (this.searchOnInput) this.next(); else { const t = this.inputElement_.value.trim(); t !== this.searchText_ && this.searchAndHighlight(t, this.preserveSelected) } } onWorkspaceKeyDown_(t) { (t.ctrlKey || t.metaKey) && t.keyCode === s.utils.KeyCodes.F && (this.open(), t.preventDefault(), t.stopPropagation()) } previous() { this.setCurrentBlock_(this.currentBlockIndex_ - 1) } next() { this.setCurrentBlock_(this.currentBlockIndex_ + 1) } setSearchPlaceholder(t) { this.textInputPlaceholder_ = t, this.inputElement_ && this.inputElement_.setAttribute("placeholder", this.textInputPlaceholder_) } setCurrentBlock_(t) { if (!this.blocks_.length) return; let e = this.blocks_[this.currentBlockIndex_]; e && this.unhighlightCurrentSelection_(e), this.currentBlockIndex_ = (t % this.blocks_.length + this.blocks_.length) % this.blocks_.length, e = this.blocks_[this.currentBlockIndex_], this.highlightCurrentSelection_(e), this.scrollToVisible_(e) } open() { this.setVisible_(!0), this.inputElement_.focus(), this.searchText_ && this.searchAndHighlight(this.searchText_) } close() { this.setVisible_(!1), this.workspace_.markFocused(), this.clearBlocks() } setVisible_(t) { this.htmlDiv_.style.display = t ? "flex" : "none" } searchAndHighlight(t, e) { const s = this.blocks_[this.currentBlockIndex_]; this.searchText_ = t.trim(), this.clearBlocks(), this.blocks_ = this.getMatchingBlocks_(this.workspace_, this.searchText_, this.caseSensitive), this.highlightSearchGroup_(this.blocks_); let i = 0; e && (i = this.blocks_.indexOf(s), i = i > -1 ? i : 0), this.setCurrentBlock_(i) } getSearchPool_(t) { return t.getAllBlocks(!0).filter((t => { const e = t.getSurroundParent(); return !e || !e.isCollapsed() })) } isBlockMatch_(t, e, s) { let i = ""; if (t.isCollapsed()) i = t.toString(); else { const e = []; t.inputList.forEach((t => { t.fieldRow.forEach((t => { e.push(t.getText()) })) })), i = e.join(" ").trim() } return s || (i = i.toLowerCase()), i.indexOf(e) > -1 } getMatchingBlocks_(t, e, s) { return e ? (this.caseSensitive || (e = e.toLowerCase()), this.getSearchPool_(t).filter((t => this.isBlockMatch_(t, e, s)))) : [] } clearBlocks() { this.unhighlightSearchGroup_(this.blocks_); const t = this.blocks_[this.currentBlockIndex_]; t && this.unhighlightCurrentSelection_(t), this.currentBlockIndex_ = -1, this.blocks_ = [] } highlightCurrentSelection_(t) { const e = t.pathObject.svgPath; s.utils.dom.addClass(e, "blockly-ws-search-current") } unhighlightCurrentSelection_(t) { const e = t.pathObject.svgPath; s.utils.dom.removeClass(e, "blockly-ws-search-current") } highlightSearchGroup_(t) { t.forEach((t => { const e = t.pathObject.svgPath; s.utils.dom.addClass(e, "blockly-ws-search-highlight") })) } unhighlightSearchGroup_(t) { t.forEach((t => { const e = t.pathObject.svgPath; s.utils.dom.removeClass(e, "blockly-ws-search-highlight") })) } scrollToVisible_(t) { if (!this.workspace_.isMovable()) return; const e = t.getRelativeToSurfaceXY(), s = this.workspace_.scale, i = t.width * s, o = t.height * s, n = e.y * s, l = (e.y + t.height) * s, c = this.workspace_.RTL ? e.x * s - i : e.x * s, h = this.workspace_.RTL ? e.x * s : e.x * s + i, r = this.workspace_.getMetrics(); let a = r.viewLeft; const d = c < r.viewLeft, u = h > r.viewLeft + r.viewWidth, p = i > r.viewWidth; !p && d || p && !this.workspace_.RTL ? a = c : (!p && u || p && this.workspace_.RTL) && (a = h - r.viewWidth); let _ = r.viewTop; const g = n < r.viewTop, b = l > r.viewTop + r.viewHeight, k = o > r.viewHeight; if (g || k && b ? _ = n : b && (_ = l - r.viewHeight), a !== r.viewLeft || _ !== r.viewTop) { const t = document.activeElement; this.workspace_.scroll(-a, -_), t && t.focus() } } } })(), o })() }));
//# sourceMappingURL=index.js.map